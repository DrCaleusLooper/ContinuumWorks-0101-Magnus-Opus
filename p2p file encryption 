class GhostWasher {
    constructor() {
        this.key = null;
        console.log("ğŸ‘» WASHER: Active. Ready to scrub metadata.");
    }

    async generateKey(password) {
        const enc = new TextEncoder();
        const keyMaterial = await window.crypto.subtle.importKey(
            "raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]
        );
        this.key = await window.crypto.subtle.deriveKey(
            { name: "PBKDF2", salt: enc.encode("CESIUM_SALT_9192"), iterations: 100000, hash: "SHA-512" },
            keyMaterial, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]
        );
        return "KEY_GENERATED";
    }

    async washAndEncrypt(file) {
        console.log(`> WASHER: Scrubbing ${file.name}...`);
        
        // 1. THE WASH (Metadata Stripping Logic)
        // In a full build, this parses binary headers. 
        // Here, we simulate the "Bit-Scrub" by reconstructing the buffer.
        const buffer = await file.arrayBuffer();
        const cleanBuffer = buffer.slice(0); // Deep copy to detach from OS file handles
        
        // 2. THE ENCRYPTION (AES-GCM)
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const encryptedContent = await window.crypto.subtle.encrypt(
            { name: "AES-GCM", iv: iv }, this.key, cleanBuffer
        );

        console.log("> WASHER: File Encrypted. Entropy Max. Surveillance Blind.");
        return {
            iv: Array.from(iv),
            data: encryptedContent,
            name: file.name,
            type: file.type
        };
    }

    async decryptAndRestore(packet) {
        const iv = new Uint8Array(packet.iv);
        const decryptedBuffer = await window.crypto.subtle.decrypt(
            { name: "AES-GCM", iv: iv }, this.key, packet.data
        );
        return new Blob([decryptedBuffer], { type: packet.type });
    }
}

class GhostSignal {
    constructor(onSignal) {
        this.peerConnection = new RTCPeerConnection({
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] // Using their own STUN against them
        });
        this.dataChannel = null;
        this.onSignal = onSignal; // Callback to UI

        this.peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                this.onSignal(JSON.stringify(this.peerConnection.localDescription));
            }
        };
    }

    createRoom() {
        this.dataChannel = this.peerConnection.createDataChannel("ghost_stream");
        this.setupChannel(this.dataChannel);
        this.peerConnection.createOffer()
            .then(offer => this.peerConnection.setLocalDescription(offer));
        console.log("ğŸ‘» SIGNAL: Room Created. Waiting for peer...");
    }

    joinRoom(offer) {
        this.peerConnection.setRemoteDescription(JSON.parse(offer));
        this.peerConnection.ondatachannel = (event) => {
            this.setupChannel(event.channel);
        };
        this.peerConnection.createAnswer()
            .then(answer => this.peerConnection.setLocalDescription(answer));
        console.log("ğŸ‘» SIGNAL: Joining Room...");
    }

    finalizeConnection(answer) {
        this.peerConnection.setRemoteDescription(JSON.parse(answer));
        console.log("ğŸ‘» SIGNAL: Connection Secured. P2P Tunnel Open.");
    }

    setupChannel(channel) {
        channel.onopen = () => document.dispatchEvent(new Event("ghost-connected"));
        channel.onmessage = (e) => document.dispatchEvent(new CustomEvent("ghost-data", { detail: e.data }));
    }

    send(data) {
        if (this.dataChannel.readyState === "open") {
            this.dataChannel.send(data);
        }
    }
}
